

startup框架任务主要是通过kotlin协程初始化第三方库

1. Startup提供start和cancel方法用于初始化和取消初始化
2. Initializer接口未来只提供一个方法 `suspend fun init(DependenciesProvider): T`
   初始化过程中需要的任何依赖有且只能是其他`Initializer`或者Startup提供的.Initializer需要使用StartupInitializer(alias:String?)
    标记,别名可选
3. `DependenciesProvider` 存储所有Initializer的初始化返回值,不包含Unit类型.
4. 我需要一个处理类,用于用户添加所有的 `Initializer` 类,然后这个处理类还需要肩负起进行依赖处理.
    编写一个注解名为 StartupDepend( val type: KClass<*>, alias:String?), 在运行时识别当前初始化类需要什么类型的数据,这个数据
   由谁提供(alias)别名,如果这个数据类型唯一不会由其他初始化类提供那么alias可以省略.反之出现多个同类型返回值的初始化器但是没有指明alias就报错,
   这个类需要在运行时通过依赖关系弄清楚他们的的初始化顺序,这可能需要在运行时通过反射获取其提供的数据类型,
   在运行时将他们进行依赖管理拓扑排序,为什么需要运行时进行呢,因为框架要脱离注解处理器生成代码
   也可以运行. 而这一步也恰恰是注解处理器要工作的内容(稍后再说注解处理器的事). 因为注解可以在运行时进行发现和处理,所以
   这个类的作用就是: 
   - 为Startup提供所有的 `Initializer` 
   - Startup.start方法执行时根据依赖关系进行拓扑排序,编排初始化顺序,哪些初始化类需要串联初始化等待其他初始化类为他
     提供依赖,哪些不需要串行初始化可以并行执行.
   - 这个类呢只需要用户提供所有 `Initializer` 类集合就可以了. 剩下的拓扑排序依赖管理都在运行时执行.
5. 可能还需要一个包装类作用是保存所有 `Initializer` 执行结束后提供的数据.将这些数据交给其他 `Initializer`类
6. 注解处理器生成代码,它的作用就是完成第4步的任务.在编译期间获取所有的 `Initializer`类,识别他们的依赖关系完成拓扑排序.
   然后生成一个在运行时说需要完成任务的类.这样开发者就不需要执行第4步操作了. 在代码实际使用中可能只需要把生成好的代码类
   交给Startup,之后再编写其他 `Initializer` ,也不需要再修改其他代码.